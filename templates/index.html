{% extends "base.html" %}

{% block content %}
<div class="main-content-wrapper">
    <div id="openseadragon-viewer" class="image-viewer-container"></div>
    <div class="controls-container">
        <div id="controls-1" class="control-panel active">
            <h3>B·∫£n ƒë·ªì</h3>
            <div class="form-group">
                <label for="map-select">Ch·ªçn b·∫£n ƒë·ªì</label>
                <select id="map-select" class="form-control">
                    {% for ban_do in danh_sach_ban_do %}
                    <option value="{{ ban_do }}">{{ ban_do }}</option>
                    {% endfor %}
                </select>
                <button id="upload-map-btn" class="btn-primary">T·∫£i b·∫£n ƒë·ªì</button>
            </div>
            <button id="update-map-btn" class="btn-toggle">C·∫≠p nh·∫≠t b·∫£n ƒë·ªì c≈©</button>

            <br><hr><br>

            <h3>T·∫°o b·∫£n ƒë·ªì m·ªõi</h3>
            <button id="create-new-map-btn" class="btn-primary">T·∫°o b·∫£n ƒë·ªì m·ªõi</button>
            <div class="input-with-button">
                <input type="text" id="new-map-name-input" class="form-control" placeholder="T√™n b·∫£n ƒë·ªì m·ªõi">
                <button id="save-new-map-btn" class="btn-primary">L∆∞u b·∫£n ƒë·ªì</button>
            </div>
            <br><hr><br>

            <h3>ƒêi·ªÅu khi·ªÉn th·ªß c√¥ng</h3>
            <button id="manual-control-btn" class="btn-toggle">ƒêi·ªÅu khi·ªÉn th·ªß c√¥ng</button>
            <div class="manual-control-group">
                <div class="control-row">
                    <button id="btn-forward" class="btn-arrow">‚ñ≤</button>
                </div>
                <div class="control-row">
                    <button id="btn-turn-left" class="btn-arrow">‚óÄ</button>
                    <button id="btn-backward" class="btn-arrow">‚ñº</button>
                    <button id="btn-turn-right" class="btn-arrow">‚ñ∂</button>
                </div>
            </div>
        </div>
        <div id="controls-2" class="control-panel">
            <h3>C√†i ƒë·∫∑t</h3>
            <div class="form-group">
                <label for="max-speed-forward">Ti·∫øn l·ªõn nh·∫•t (m/s)</label>
                <select id="max-speed-forward" class="form-control">
                    {% for van_toc in list_van_toc %}
                    <option value="{{ van_toc }}" {% if van_toc == dict_cai_dat["tien_max"] %}selected{% endif %}>{{ van_toc }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="form-group">
                <label for="max-speed-turn">R·∫Ω l·ªõn nh·∫•t (ƒë·ªô/s)</label>
                <select id="max-speed-turn" class="form-control">
                    {% for van_toc_re in list_van_toc_re %}
                    <option value="{{ van_toc_re }}" {% if van_toc_re == dict_cai_dat["re_max"] %}selected{% endif %}>{{ van_toc_re }}</option>
                    {% endfor %}
                </select>
            </div>
            <button id="update-settings-btn" class="btn-primary">C·∫≠p nh·∫≠t</button>
        </div>
        <div id="controls-3" class="control-panel">
            <h3>L·ª±a ch·ªçn v·ªã tr√≠</h3>
            <button id="set-current-pos-btn" class="btn-location-select" data-target="vi_tri_agv_hien_tai" data-color="red">V·ªã tr√≠ robot hi·ªán t·∫°i c·ªßa robot</button>
            <button id="set-start-pos-btn" class="btn-location-select" data-target="vi_tri_bat_dau_lam_viec" data-color="yellow">V·ªã tr√≠ b·∫Øt ƒë·∫ßu l√†m vi·ªác</button>
            <button id="set-end-pos-btn" class="btn-location-select" data-target="vi_tri_ket_thuc_lam_viec" data-color="green">V·ªã tr√≠ k·∫øt th√∫c l√†m vi·ªác</button>
            <button id="set-charge-pos-btn" class="btn-location-select" data-target="vi_tri_sac_agv" data-color="blue">V·ªã tr√≠ s·∫°c c·ªßa robot</button>
            
            <div id="angle-controls" class="angle-controls-group" style="display: none;">
                <label for="angle-input">G√≥c:</label>
                <div class="angle-controls-row">
                    <button id="btn-angle-left" class="btn-angle">‚óÄ</button>
                    <input type="number" id="angle-input" class="form-control" value="0">
                    <button id="btn-angle-right" class="btn-angle">‚ñ∂</button>
                </div>
            </div>
        </div>
        <div id="controls-4" class="control-panel">
            <h3>Khu v·ª±c l√†m vi·ªác</h3>
            <div class="form-group">
                <h4>T·∫°o khu v·ª±c</h4>
                <button id="create-area-btn">Th√™m khu v·ª±c l√†m vi·ªác</button>
            </div>
            <div class="form-group">
                <h4>Ch·ªânh s·ª≠a khung</h4>
                <div class="input-with-button">
                    <select id="area-select" class="form-control">
                    </select>
                </div>
                <button id="delete-area-btn" class="btn-primary">X√≥a</button>
                <button id="edit-area-btn">Ch·ªânh s·ª≠a khung l√†m vi·ªác</button>
            </div>
            <div class="form-group">
                <h4>L∆∞u danh s√°ch khu v·ª±c</h4>
                <div class="form-group">
                    <input type="text" id="new-area-name" class="form-control" placeholder="T√™n khu v·ª±c m·ªõi">
                    <button id="save-area-btn" class="btn-primary">L∆∞u khu v·ª±c l√†m vi·ªác</button>
                </div>
            </div>
            <div class="form-group">
                <h4>M·ªü danh s√°ch khu v·ª±c</h4>
                <div class="form-group">
                    <select id="area-list-select" class="form-control">
                        {% for area_list_name in khu_vuc_lam_viec["danh_sach_khu_vuc_mo"] %}
                        <option value="{{ area_list_name }}">{{ area_list_name }}</option>
                        {% endfor %}
                    </select>
                    <button id="open-area-btn" class="btn-primary">M·ªü khu v·ª±c l√†m vi·ªác</button>
                </div>
            </div>
        </div>
        <div id="controls-5" class="control-panel">
            <h3>Ch·∫°y robot</h3>
            <button id="btn-run-stop" class="btn-run">Ch·∫°y</button>
            <button id="btn-finish">K·∫øt th√∫c</button>
        </div>
    </div>
    <div id="logo-container">
        <img src="{{ url_for('static', filename='teemo.png') }}" alt="Logo">
    </div>
</div>

<script type="text/javascript">
    let viewer;
    const bluePointOverlays = [];
    const redPointOverlays = [];
    const osdAgvBodyPointOverlays = [];
    const osdAgvArrowPointOverlays = [];
    let specialLocationOverlays = {}; // Object to store overlays for special locations
    let specialLocationOverlays_new = {}

    // Khai b√°o c√°c bi·∫øn tr·∫°ng th√°i ·ªü ƒë√¢y ƒë·ªÉ c√≥ th·ªÉ truy c·∫≠p to√†n c·ª•c
    let isDrawingMode = false;
    let rectCount = 0;
    let activeRect = null;
    let startPoint = null;
    let workingAreaOverlays = {}; // Object ƒë·ªÉ l∆∞u tr·ªØ c√°c overlay khu v·ª±c l√†m vi·ªác
    let isDraggingOverlay = false; // Bi·∫øn tr·∫°ng th√°i m·ªõi ƒë·ªÉ theo d√µi vi·ªác k√©o overlay
    // C√°c bi·∫øn tr·∫°ng th√°i m·ªõi ƒë·ªÉ qu·∫£n l√Ω vi·ªác k√©o th·∫£
    let isResizingOverlay = false;
    let activeOverlayElement = null;
    let startPointOnImage = null;

    let isEditingMode = false;
    let activeAreaName = null;

    // Th√™m c√°c bi·∫øn tr·∫°ng th√°i ƒë·ªÉ x·ª≠ l√Ω logic 2 b∆∞·ªõc
    let activeLocationSelection = null;

    // bi·∫øn l∆∞u tr·∫°ng th√°i t·∫°o b·∫£n ƒë·ªì m·ªõi
    let creat_new_map_btn = 0;

    // H√†m ƒë·ªÉ t√≠nh to√°n g√≥c t·ª´ m·ªôt ƒëi·ªÉm ƒë·∫øn m·ªôt ƒëi·ªÉm kh√°c
    function getAngle(centerPoint, newPoint) {
        const dx = newPoint.x - centerPoint.x;
        const dy = newPoint.y - centerPoint.y;
        let angleDeg = Math.atan2(dy, dx) * 180 / Math.PI;
        return (angleDeg + 360) % 360; // ƒê·∫£m b·∫£o g√≥c lu√¥n d∆∞∆°ng t·ª´ 0 ƒë·∫øn 360 ƒë·ªô
    }

    // H√†m ƒë·ªÉ g·ª≠i g√≥c m·ªõi l√™n server
    function updateAngleOnServer(locationType, angle) {
        fetch('/update_location', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                location_type: locationType,
                angle: angle,
                update: 1
            }),
        })
        .then(response => response.json())
        .then(data => {
            console.log('Location angle updated:', data.message);
            // üî• V·∫Ω l·∫°i sau khi server ƒë√£ c·∫≠p nh·∫≠t
            fetchAndUpdateLocations();
        })
        .catch(error => console.error('Error updating angle:', error));
    }
    // H√†m n√†y s·∫Ω l·∫•y d·ªØ li·ªáu t·ª´ server v√† c·∫≠p nh·∫≠t t·∫•t c·∫£ c√°c l·ªõp ph·ªß
    function fetchAndUpdateLocations() {
        fetch('/get_all_locations')
            .then(response => response.json())
            .then(data => {
                if (data) {
                    const locationsDict = data.dict_lua_chon_vi_tri;
                    console.log("locationsDict", locationsDict)

                    const specialPoints = Object.entries(locationsDict).map(([key, loc]) => ({
                        x: loc.toa_do_x,
                        y: loc.toa_do_y,
                        type: key,                // d√πng key thay v√¨ loc.vi_tri
                        color: loc.color,         // s·ª≠a l·∫°i t·ª´ mau_sac ‚Üí color
                        angle: loc.goc_agv
                    }));
                    console.log("specialPoints", specialPoints)
                    updateSpecialLocations(specialPoints);
                } else {
                    updateSpecialLocations([]); 
                }
            })
            .catch(error => console.error('Error fetching locations:', error));
    }


    document.addEventListener('DOMContentLoaded', function() {
        viewer = OpenSeadragon({
            id: "openseadragon-viewer",
            prefixUrl: "{{ url_for('static', filename='images/') }}",
            tileSources: {
                type: 'image',
                url:  '{{ url_for("img_none_all") }}'
            },
            animationTime: 0.1,
            blendTime: 0,
            constrainDuringPan: true,
            visibilityRatio: 0.5,
            zoomPerClick: 1.0,
            maxZoomPixelRatio: 5,
            zoomPerScroll: 1.2,
            showNavigator: true,
            navigatorPosition: "TOP_RIGHT",
        });

        viewer.addHandler('open', function() {
            const savedState = sessionStorage.getItem('osdViewerState');
            if (savedState) {
                const viewerState = JSON.parse(savedState);
                viewer.viewport.panTo(new OpenSeadragon.Point(viewerState.center.x, viewerState.center.y), true);
                viewer.viewport.zoomTo(viewerState.zoom, true);
            }
            setInterval(fetchAGVState, 1000);
            
            viewer.addHandler('canvas-click', function(event) {
                if (activeLocationSelection) {
                    const webPoint = event.position;
                    const viewportPoint = viewer.viewport.pointFromPixel(webPoint);
                    const imagePoint = viewer.viewport.viewportToImageCoordinates(viewportPoint);

                    if (imagePoint && imagePoint.x >= 0 && imagePoint.y >= 0) {
                        fetch('/update_location', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                location_type: activeLocationSelection.target,
                                coords: { x: Math.round(imagePoint.x), y: Math.round(imagePoint.y) },
                                update: 1
                            }),
                        })
                        .then(response => response.json())
                        .then(data => {
                            console.log('Location coordinates updated:', data.message);
                            fetchAndUpdateLocations(); // C·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c sau khi ƒë·∫∑t ƒëi·ªÉm
                        })
                        .catch(error => console.error('Error updating coordinates:', error));
                    }
                }
                
                if (isDrawingMode) {
                    const webPoint = event.position;
                    const viewportPoint = viewer.viewport.pointFromPixel(webPoint);
                    const imagePoint = viewer.viewport.viewportToImageCoordinates(viewportPoint);

                    if (imagePoint && imagePoint.x >= 0 && imagePoint.y >= 0) {
                        rectCount++;
                        const areaName = `KV ${rectCount}`;
                        const rect = {
                            x: Math.round(imagePoint.x),
                            y: Math.round(imagePoint.y),
                            width: 100,
                            height: 100,
                        };
                        
                        // D√≤ng ƒë√£ ƒë∆∞·ª£c s·ª≠a: G·ª≠i t√™n v√† t·ªça ƒë·ªô ri√™ng bi·ªát
                        sendAreaUpdate(areaName, rect, 'add');
                        // isDrawingMode = false;
                        // createAreaBtn.classList.remove('btn-toggle-blue');
                    }
                } else if (isEditingMode && activeAreaName) {
                    const webPoint = event.position;
                    const viewportPoint = viewer.viewport.pointFromPixel(webPoint);
                    const clickPointOnImage = viewer.viewport.viewportToImageCoordinates(viewportPoint);

                    const overlayData = workingAreaOverlays[activeAreaName];
                    const areaData = overlayData.data;

                    const corners = {
                        'top-left': { x: areaData.x, y: areaData.y },
                        'top-right': { x: areaData.x + areaData.width, y: areaData.y },
                        'bottom-left': { x: areaData.x, y: areaData.y + areaData.height },
                        'bottom-right': { x: areaData.x + areaData.width, y: areaData.y + areaData.height },
                    };
                    
                    let closestCorner = null;
                    let minDistance = Infinity;

                    for (const pos in corners) {
                        const corner = corners[pos];
                        const dist = Math.sqrt(Math.pow(corner.x - clickPointOnImage.x, 2) + Math.pow(corner.y - clickPointOnImage.y, 2));
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestCorner = pos;
                        }
                    }
                    
                    let newRect = { ...areaData };
                    if (closestCorner.includes('right')) {
                        newRect.width = clickPointOnImage.x - areaData.x;
                    } else {
                        newRect.width = areaData.x + areaData.width - clickPointOnImage.x;
                        newRect.x = clickPointOnImage.x;
                    }

                    if (closestCorner.includes('bottom')) {
                        newRect.height = clickPointOnImage.y - areaData.y;
                    } else {
                        newRect.height = areaData.y + areaData.height - clickPointOnImage.y;
                        newRect.y = clickPointOnImage.y;
                    }
                    
                    if (newRect.width < 0) {
                        newRect.x = newRect.x + newRect.width;
                        newRect.width = Math.abs(newRect.width);
                    }
                    if (newRect.height < 0) {
                        newRect.y = newRect.y + newRect.height;
                        newRect.height = Math.abs(newRect.height);
                    }

                    Object.assign(areaData, newRect);
                    // D√≤ng ƒë√£ ƒë∆∞·ª£c s·ª≠a: G·ª≠i t√™n v√† t·ªça ƒë·ªô ri√™ng bi·ªát
                    sendAreaUpdate(activeAreaName, areaData, 'resize');
                }
            });
        });
    });

    // --- C√ÅC H√ÄM X·ª¨ L√ù L·ªöP PH·ª¶ V√Ä TR·∫†NG TH√ÅI ---
    function updateAGVOnMap(bodyCoordsList, arrowCoordsList) {
        if (!viewer || !viewer.isOpen() || !viewer.world.getItemCount() > 0) return;

        const imageItem = viewer.world.getItemAt(0);
        if (!imageItem || !imageItem.source || !imageItem.source.dimensions) return;

        osdAgvBodyPointOverlays.forEach(overlayObj => {
            if (overlayObj && overlayObj.element) {
                viewer.removeOverlay(overlayObj.element);
            }
        });
        osdAgvBodyPointOverlays.length = 0;

        osdAgvArrowPointOverlays.forEach(overlayObj => {
            if (overlayObj && overlayObj.element) {
                viewer.removeOverlay(overlayObj.element);
            }
        });
        osdAgvArrowPointOverlays.length = 0;

        const imageWidth = imageItem.source.dimensions.x;
        const imageHeight = imageItem.source.dimensions.y;
        if (imageWidth === 0 || imageHeight === 0) return;

        if (bodyCoordsList && bodyCoordsList.length > 0) {
            bodyCoordsList.forEach(coords => {
                const xForOSD = parseFloat(coords[0]) / imageWidth;
                const yForOSD = parseFloat(coords[1]) / imageHeight;
                const pointElement = document.createElement("div");
                pointElement.style.width = "3px";
                pointElement.style.height = "3px";
                pointElement.style.backgroundColor = "blue";
                pointElement.style.borderRadius = "50%";
                pointElement.style.transform = "translate(-50%, -50%)";
                viewer.addOverlay({ element: pointElement, location: new OpenSeadragon.Point(xForOSD, yForOSD), placement: OpenSeadragon.Placement.CENTER, checkResize: false });
                osdAgvBodyPointOverlays.push({ element: pointElement });
            });
        }

        if (arrowCoordsList && arrowCoordsList.length > 0) {
            arrowCoordsList.forEach(coords => {
                const xForOSD = parseFloat(coords[0]) / imageWidth;
                const yForOSD = parseFloat(coords[1]) / imageHeight;
                const pointElement = document.createElement("div");
                pointElement.style.width = "3px";
                pointElement.style.height = "3px";
                pointElement.style.backgroundColor = "red";
                pointElement.style.borderRadius = "50%";
                pointElement.style.transform = "translate(-50%, -50%)";
                viewer.addOverlay({ element: pointElement, location: new OpenSeadragon.Point(xForOSD, yForOSD), placement: OpenSeadragon.Placement.CENTER, checkResize: false });
                osdAgvArrowPointOverlays.push({ element: pointElement });
            });
        }
    }

    function updateSpecialPoints(pointsArray, colorString, overlayStorageArray) {
        if (!viewer || !viewer.isOpen()) return;

        overlayStorageArray.forEach(overlayObj => {
            if (overlayObj && overlayObj.element) {
                viewer.removeOverlay(overlayObj.element);
            }
        });
        overlayStorageArray.length = 0;

        let imageWidth = 0;
        let imageHeight = 0;
        if (viewer.world.getItemCount() > 0) {
            const tiledImage = viewer.world.getItemAt(0);
            if (tiledImage && tiledImage.source && tiledImage.source.dimensions) {
                imageWidth = tiledImage.source.dimensions.x;
                imageHeight = tiledImage.source.dimensions.y;
            } else if (tiledImage && tiledImage.source && tiledImage.source.width && tiledImage.source.height) {
                imageWidth = tiledImage.source.width;
                imageHeight = tiledImage.source.height;
            }
        }
        if (imageWidth === 0 || imageHeight === 0) return;

        pointsArray.forEach(pointCoords => {
            const x_pixel = parseFloat(pointCoords[0]);
            const y_pixel = parseFloat(pointCoords[1]);
            if (isNaN(x_pixel) || isNaN(y_pixel)) return;

            const x_normalized = x_pixel / imageWidth;
            const y_normalized = y_pixel / imageHeight;
            const pointLocation = new OpenSeadragon.Point(x_normalized, y_normalized);
            const pointElement = document.createElement("div");
            pointElement.style.width = "5px";
            pointElement.style.height = "5px";
            pointElement.style.backgroundColor = colorString;
            pointElement.style.borderRadius = "50%";
            pointElement.style.transform = "translate(-50%, -50%)";
            viewer.addOverlay({ element: pointElement, location: pointLocation, placement: OpenSeadragon.Placement.CENTER });
            overlayStorageArray.push({ element: pointElement, location: pointLocation });
        });
    }

    // H√†m c·∫≠p nh·∫≠t c√°c ƒëi·ªÉm ƒë·∫∑c bi·ªát v·ªõi m≈©i t√™n c√≥ th·ªÉ xoay
    function updateSpecialLocations(pointsArray) {
        if (!viewer || !viewer.isOpen() || !viewer.world.getItemCount() > 0) return;

        // X√≥a t·∫•t c·∫£ c√°c l·ªõp ph·ªß c≈© tr∆∞·ªõc khi v·∫Ω l·∫°i
        for (const type in specialLocationOverlays) {
            specialLocationOverlays[type].forEach(overlayObj => viewer.removeOverlay(overlayObj.element));
            delete specialLocationOverlays[type];
        }
        specialLocationOverlays = {};

        const imageItem = viewer.world.getItemAt(0);
        const imageWidth = imageItem.source.dimensions.x;
        const imageHeight = imageItem.source.dimensions.y;
        if (imageWidth === 0 || imageHeight === 0) return;

        pointsArray.forEach(pointData => {
            const x_normalized = pointData.x / imageWidth;
            const y_normalized = pointData.y / imageHeight;
            const pointLocation = new OpenSeadragon.Point(x_normalized, y_normalized);
            const type = pointData.type;
            const color = pointData.color;
            const angle = pointData.angle;

            console.log("angle---------", angle)

            const pointElement = document.createElement("div");
            pointElement.className = "special-location-overlay";
            pointElement.dataset.locationType = type;
            pointElement.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
            pointElement.style.position = "absolute";
            pointElement.style.pointerEvents = "none";

            const pointDot = document.createElement("div");
            pointDot.style.width = "10px";
            pointDot.style.height = "10px";
            pointDot.style.backgroundColor = color;
            pointDot.style.borderRadius = "50%";
            pointDot.style.position = "absolute";
            pointDot.style.top = "50%";
            pointDot.style.left = "50%";
            pointDot.style.transform = "translate(-50%, -50%)";

            pointElement.className = "arrow-container";
            pointElement.style.transform = `translate(-50%, -50%)`;
            pointElement.style.rotate = `${angle}deg`;


            // T·∫°o m≈©i t√™n tr∆∞·ªõc
            const arrowHead = document.createElement("div");
            // arrowHead.className = "arrow-head";
            arrowHead.style.position = "absolute";
            arrowHead.style.width = "0";
            arrowHead.style.height = "0";
            arrowHead.style.borderLeft = "7px solid transparent";
            arrowHead.style.borderRight = "7px solid transparent";
            arrowHead.style.borderBottom = `15px solid ${color}`;
            arrowHead.style.top = "-15px";
            arrowHead.style.left = "50%";
            arrowHead.style.transform = "translate(-50%, -50%)";  // üëà s·ª≠a ·ªü ƒë√¢y
            pointElement.style.transform = `${angle}deg`;

            // R·ªìi m·ªõi append v√†o pointElement
            pointElement.appendChild(arrowHead);

            pointElement.appendChild(pointDot);

            const overlay = viewer.addOverlay({
                element: pointElement,
                location: pointLocation,
                placement: OpenSeadragon.Placement.CENTER,
                checkResize: false
            });

            if (!specialLocationOverlays[type]) {
                specialLocationOverlays[type] = [];
            }
            specialLocationOverlays[type].push({ element: pointElement, overlay: overlay });

            
            // C·∫≠p nh·∫≠t gi√° tr·ªã g√≥c tr√™n √¥ input n·∫øu v·ªã tr√≠ n√†y ƒëang ƒë∆∞·ª£c ch·ªçn
            if (activeLocationSelection && activeLocationSelection.target === type) {
                 document.getElementById('angle-input').value = Math.round(angle);
            }
        });
    }


    function fetchAGVState() {
        fetch('/get_agv_state')
            .then(response => response.json())
            .then(data => {
                if (data.points_blue) {
                    updateSpecialPoints(data.points_blue, 'blue', bluePointOverlays);
                }
                if (data.points_red) {
                    updateSpecialPoints(data.points_red, 'red', redPointOverlays);
                }
                if (data.agv_body_coords && data.agv_arrow_coords) {
                    updateAGVOnMap(data.agv_body_coords, data.agv_arrow_coords);
                }
                if (data.special_points) {
                    updateSpecialLocations(data.special_points);
                } else {
                    // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, x√≥a c√°c l·ªõp ph·ªß c≈©
                    for (const type in specialLocationOverlays) {
                        specialLocationOverlays[type].forEach(overlayObj => viewer.removeOverlay(overlayObj.element));
                        delete specialLocationOverlays[type];
                    }
                }
            })
            .catch(error => console.error('Error fetching AGV state:', error));
    }


    const btnAngleLeft = document.getElementById('btn-angle-left');
    const btnAngleRight = document.getElementById('btn-angle-right');

    const locationButtons = document.querySelectorAll('.btn-location-select');
    const angleControlsDiv = document.getElementById('angle-controls');
    const angleInput = document.getElementById('angle-input');

    locationButtons.forEach(button => {
        button.addEventListener('click', function() {
            // B·ªè active cho t·∫•t c·∫£ button
            locationButtons.forEach(btn => btn.classList.remove('btn-active-blue'));

            if (activeLocationSelection && activeLocationSelection.button === this) {
                // N·∫øu b·∫•m l·∫°i n√∫t ƒëang ch·ªçn th√¨ h·ªßy ch·ªçn
                this.classList.remove('btn-active-blue');
                activeLocationSelection = null;
                angleControlsDiv.style.display = 'none';
            } else {
                // Ch·ªçn n√∫t m·ªõi
                this.classList.add('btn-active-blue');
                activeLocationSelection = {
                    target: this.dataset.target,
                    color: this.dataset.color,
                    button: this
                };
                angleControlsDiv.style.display = 'block';

                // L·∫•y g√≥c hi·ªán t·∫°i t·ª´ server
                fetch('/get_all_locations')
                    .then(res => res.json())
                    .then(dict => {
                        if (dict[activeLocationSelection.target]) {
                            const currentAngle = dict[activeLocationSelection.target].goc_agv;
                            angleInput.value = Math.round(currentAngle);
                        } else {
                            angleInput.value = 0;
                        }
                    })
                    .catch(err => {
                        console.error("Error fetching angle:", err);
                        angleInput.value = 0;
                    });
            }
        });
    });

    btnAngleLeft.addEventListener('click', function() {
        if (activeLocationSelection) {
            let currentAngle = parseFloat(angleInput.value);
            currentAngle = (currentAngle - 1 + 360) % 360; // Gi·∫£m 1 ƒë·ªô v√† ƒë·∫£m b·∫£o n·∫±m trong kho·∫£ng 0-359
            angleInput.value = Math.round(currentAngle);
            updateAngleOnServer(activeLocationSelection.target, currentAngle);
        }
    });

    btnAngleRight.addEventListener('click', function() {
        if (activeLocationSelection) {
            let currentAngle = parseFloat(angleInput.value);
            currentAngle = (currentAngle + 1) % 360; // TƒÉng 1 ƒë·ªô v√† ƒë·∫£m b·∫£o n·∫±m trong kho·∫£ng 0-359
            angleInput.value = Math.round(currentAngle);
            updateAngleOnServer(activeLocationSelection.target, currentAngle);
            // ki·ªÉm tra xem c√≥ v√†o kh√¥ng
            console.log("currentAngle", currentAngle);
        }
    });

    angleInput.addEventListener('change', function() {
        if (activeLocationSelection) {
            let newAngle = parseFloat(this.value);
            if (!isNaN(newAngle)) {
                newAngle = (newAngle + 360) % 360; // ƒê·∫£m b·∫£o g√≥c h·ª£p l·ªá
                this.value = Math.round(newAngle);
                updateAngleOnServer(activeLocationSelection.target, newAngle);
            }
        }
    });

    
    // --- LOGIC GIAO DI·ªÜN ---
    const menuLinks = document.querySelectorAll('#main-menu a');
    const controlPanels = document.querySelectorAll('.control-panel');
    const mainWrapper = document.querySelector('.main-content-wrapper');

    function switchPanel(targetId) {
        menuLinks.forEach(link => {
            link.classList.toggle('active', link.getAttribute('data-target') === targetId);
        });

        if (targetId === 'fullscreen') {
            mainWrapper.classList.add('fullscreen-mode');
        } else {
            mainWrapper.classList.remove('fullscreen-mode');
            controlPanels.forEach(panel => {
                panel.classList.toggle('active', panel.id === targetId);
            });
        }
    }
    menuLinks.forEach(link => {
        link.addEventListener('click', function(event) {
            event.preventDefault();
            const targetId = this.getAttribute('data-target');
            switchPanel(targetId);
        });
    });
    switchPanel('controls-1');

    // C√†i ƒë·∫∑t chung
    const updateSettingsBtn = document.getElementById('update-settings-btn');
    if (updateSettingsBtn) {
        updateSettingsBtn.addEventListener('click', function() {
            this.classList.add('btn-active-blue');
            this.disabled = true;

            fetch('/update_setting', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    tien_max: parseFloat(document.getElementById('max-speed-forward').value),
                    re_max: parseFloat(document.getElementById('max-speed-turn').value),
                    update: 1 
                }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('C√†i ƒë·∫∑t ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng v√† c·ªù ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t.');
                }
            })
            .catch(error => {
                console.error('L·ªói khi g·ª≠i y√™u c·∫ßu c·∫≠p nh·∫≠t:', error);
            })
            .finally(() => {
                setTimeout(() => {
                    this.classList.remove('btn-active-blue');
                    this.disabled = false;
                }, 2000);
            });
        });
    }

    const toggleButtons = document.querySelectorAll('.btn-toggle');
    toggleButtons.forEach(button => {
        button.addEventListener('click', function() {
            this.classList.toggle('btn-active-blue');
        });
    });

    const runStopButton = document.getElementById('btn-run-stop');
    if (runStopButton) {
        runStopButton.addEventListener('click', function() {
            if (this.classList.contains('btn-run')) {
                this.classList.replace('btn-run', 'btn-stop');
                this.textContent = 'D·ª´ng';
            } else {
                this.classList.replace('btn-stop', 'btn-run');
                this.textContent = 'Ch·∫°y';
            }
        });
    }

    const finishButton = document.getElementById('btn-finish');
    if (finishButton && runStopButton) {
        finishButton.addEventListener('click', function() {
            runStopButton.classList.replace('btn-stop', 'btn-run');
            runStopButton.textContent = 'Ch·∫°y';
            this.classList.add('btn-active-blue');
            setTimeout(() => { this.classList.remove('btn-active-blue'); }, 2000);
        });
    }

    const saveAreaButton = document.getElementById('btn-save-area');
    if (saveAreaButton) {
        saveAreaButton.addEventListener('click', function() {
            this.classList.add('btn-save-success');
            setTimeout(() => {
                this.classList.remove('btn-save-success');
            }, 2000);
        });
    }
    
    // --- C√ÅC H√ÄM M·ªöI THEO Y√äU C·∫¶U ---

    // 1. T·∫£i b·∫£n ƒë·ªì c≈© v√† c·∫≠p nh·∫≠t
    const uploadBtn = document.getElementById('upload-map-btn');
    if (uploadBtn) {
        uploadBtn.addEventListener('click', function() {
            const selectedMap = document.getElementById('map-select').value;
            this.classList.add('active');
            this.disabled = true;

            fetch('/update_map_status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'load_old_map', map_name: selectedMap }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Server response:', data.message);
                    viewer.open({
                        type: 'image',
                        url:  '{{ url_for("img_none_all") }}?' + new Date().getTime()
                    });
                } else {
                    alert('L·ªói khi t·∫£i b·∫£n ƒë·ªì: ' + data.message);
                }
            })
            .catch(error => {
                console.error('L·ªói k·∫øt n·ªëi:', error);
                alert('ƒê√£ x·∫£y ra l·ªói k·∫øt n·ªëi t·ªõi server.');
            })
            .finally(() => {
                setTimeout(() => {
                    uploadBtn.classList.remove('active');
                    uploadBtn.disabled = false;
                }, 2000);
            });
        });
    }

    const updateMapBtn = document.getElementById('update-map-btn');
    if (updateMapBtn) {
        updateMapBtn.addEventListener('click', function() {
            const isToggled = this.classList.toggle('btn-active-blue');
            fetch('/update_map_status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'update_old_map', status: isToggled ? 1 : 0 }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
            })
            .catch(error => console.error('Error updating map status:', error));
        });
    }

    // 2. T·∫°o b·∫£n ƒë·ªì m·ªõi
    const createNewMapBtn = document.getElementById('create-new-map-btn');
    if (createNewMapBtn) {
        createNewMapBtn.addEventListener('click', function() {
            // this.classList.add('btn-active-blue');
            creat_new_map_btn = this.classList.toggle('btn-active-blue');
            // this.disabled = true;
            fetch('/update_map_status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'create_new_map' , status: creat_new_map_btn ? 1 : 0}),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
            })
            .catch(error => console.error('Error creating new map:', error))
            .finally(() => {
                setTimeout(() => {
                    // this.classList.remove('btn-active-blue');
                    // this.disabled = false;
                }, 2000);
            });
        });
    }

    const newMapNameInput = document.getElementById('new-map-name-input');
    if (newMapNameInput) {
        newMapNameInput.addEventListener('input', function() {
            fetch('/update_map_status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'update_new_map_name', map_name: this.value }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
            })
            .catch(error => console.error('Error updating new map name:', error));
        });
    }

    const saveNewMapBtn = document.getElementById('save-new-map-btn');
    if (saveNewMapBtn) {
        saveNewMapBtn.addEventListener('click', function() {
            const mapName = newMapNameInput.value.trim();
            if (mapName === "") {
                alert("Vui l√≤ng nh·∫≠p t√™n b·∫£n ƒë·ªì m·ªõi.");
                return;
            }
            this.classList.add('btn-active-blue');
            this.disabled = true;
            fetch('/update_map_status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'save_new_map' }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
                console.log('Map list:', data.map_list);
                updateMapSelect(data.map_list)
            })
            .catch(error => console.error('Error saving new map:', error))
            .finally(() => {
                setTimeout(() => {
                    this.classList.remove('btn-active-blue');
                    this.disabled = false;
                    createNewMapBtn.classList.remove('btn-active-blue');
                }, 2000);
            });
        });
    }
    // H√†m ƒë·ªÉ c·∫≠p nh·∫≠t combobox B·∫£n ƒë·ªì upload_map
    function updateMapSelect(mapList) {
        const mapSelect = document.getElementById('map-select');
        // X√≥a c√°c l·ª±a ch·ªçn c≈©
        mapSelect.innerHTML = '';
        // Th√™m c√°c l·ª±a ch·ªçn m·ªõi t·ª´ d·ªØ li·ªáu JSON
        mapList.forEach(mapName => {
            const option = document.createElement('option');
            option.value = mapName;
            option.textContent = mapName;
            mapSelect.appendChild(option);
        });
        console.log('Combobox b·∫£n ƒë·ªì ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.');
    }

    // 3. ƒêi·ªÅu khi·ªÉn th·ªß c√¥ng
    const manualControlBtn = document.getElementById('manual-control-btn');
    if (manualControlBtn) {
        manualControlBtn.addEventListener('click', function() {
            const isToggled = this.classList.toggle('btn-active-blue');
            fetch('/update_map_status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'manual_control', status: isToggled ? 1 : 0 }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
            })
            .catch(error => console.error('Error toggling manual control:', error));
        });
    }

    // --------------------------------------------------------------------------------------------
    // Th√™m logic cho ch·ª©c nƒÉng "L∆∞u v√† M·ªü danh s√°ch khu v·ª±c"
    const openAreaBtn = document.getElementById('open-area-btn');
    const saveAreaBtn = document.getElementById('save-area-btn');
    const newAreaNameInput = document.getElementById('new-area-name');
    const workingAreaSelect = document.getElementById('area-list-select');

    openAreaBtn.addEventListener('click', function() {
        const areaName = workingAreaSelect.value;
        if (areaName) {
            this.classList.add('btn-active-blue');
            fetch('/open_working_area', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: areaName }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
            })
            .catch(error => console.error('Error opening area list:', error))
            .finally(() => {
                setTimeout(() => {
                    this.classList.remove('btn-active-blue');
                }, 2000);
            });
        } else {
            alert('Vui l√≤ng ch·ªçn m·ªôt khu v·ª±c l√†m vi·ªác ƒë·ªÉ m·ªü.');
        }
    });

    saveAreaBtn.addEventListener('click', function() {
        const newAreaListName = newAreaNameInput.value.trim();
        if (newAreaListName) {
            // Th√™m class ngay l·∫≠p t·ª©c khi n√∫t ƒë∆∞·ª£c nh·∫•n
            this.classList.add('btn-active-blue');

            fetch('/save_working_area', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newAreaListName })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response:', data.message);
            })
            .catch(error => {
                console.error('Error saving area list:', error);
                // X·ª≠ l√Ω l·ªói n·∫øu c·∫ßn
            })
            .finally(() => {
                // X√≥a class sau 2 gi√¢y, b·∫•t k·ªÉ y√™u c·∫ßu th√†nh c√¥ng hay th·∫•t b·∫°i
                setTimeout(() => {
                    this.classList.remove('btn-active-blue');
                }, 2000);
            });
        } else {
            alert('T√™n khu v·ª±c kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.');
        }
    });

    // ------------------ LOGIC M·ªöI CHO KHU V·ª∞C L√ÄM VI·ªÜC ------------------
    const createAreaBtn = document.getElementById('create-area-btn');
    const deleteAreaBtn = document.getElementById('delete-area-btn');
    const areaSelect = document.getElementById('area-select');
    const editAreaBtn = document.getElementById('edit-area-btn');

    // let isDrawingMode = false;
    // let isEditingMode = false;
    // let rectCount = 0;
    // let workingAreaOverlays = {};
    // let activeAreaName = null;

    // Ch·∫ø ƒë·ªô th√™m khu v·ª±c l√†m vi·ªác
    createAreaBtn.addEventListener('click', function() {
        // S·ª≠ d·ª•ng classList.toggle ƒë·ªÉ chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i c·ªßa n√∫t
        isDrawingMode = this.classList.toggle('btn-active-blue');

        isEditingMode = false; // T·∫Øt ch·∫ø ƒë·ªô ch·ªânh s·ª≠a
        editAreaBtn.classList.remove('btn-active-blue'); // ƒê·∫∑t l·∫°i m√†u cho n√∫t ch·ªânh s·ª≠a

        console.log("creat mode: " + isDrawingMode);

        // if (!isDrawingMode) {
        //     isDrawingMode = true;
        //     isEditingMode = false; // T·∫Øt ch·∫ø ƒë·ªô ch·ªânh s·ª≠a
        //     editAreaBtn.classList.remove('btn-active-blue'); // ƒê·∫∑t l·∫°i m√†u cho n√∫t ch·ªânh s·ª≠a
        //     this.classList.add('btn-active-blue');
        //     console.log("Drawing mode: true");
        // } else {
        //     isDrawingMode = false;
        //     this.classList.remove('btn-active-blue');
        //     console.log("Drawing mode: false");
        // }
    });

    // Ch·∫ø ƒë·ªô ch·ªânh s·ª≠a khu v·ª±c l√†m vi·ªác
    editAreaBtn.addEventListener('click', function() {
        // S·ª≠ d·ª•ng classList.toggle ƒë·ªÉ chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i c·ªßa n√∫t
        isEditingMode = this.classList.toggle('btn-active-blue');
        
        // ƒê·∫£m b·∫£o ch·ªâ c√≥ m·ªôt ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông
        isDrawingMode = false;
        createAreaBtn.classList.remove('btn-active-blue');
        
        console.log("Editing mode: " + isEditingMode);
    });

    // L·∫Øng nghe s·ª± ki·ªán thay ƒë·ªïi c·ªßa combobox
    areaSelect.addEventListener('change', function() {
        activeAreaName = this.value;
        updateOverlayStyles();
    });

    // C·∫≠p nh·∫≠t combobox v√† c√°c overlay t·ª´ d·ªØ li·ªáu server
    function updateAreaSelectAndOverlays() {
        fetch('/get_working_areas')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Fetched areas from server:", data.cac_khu_vuc_lam_viec);
                areaSelect.innerHTML = '';
                
                const validAreas = data.cac_khu_vuc_lam_viec.filter(area => area.name);

                if (validAreas.length > 0) {
                    validAreas.forEach(area => {
                        const option = document.createElement('option');
                        option.value = area.name;
                        option.textContent = area.name;
                        areaSelect.appendChild(option);
                    });
                    areaSelect.value = activeAreaName || validAreas[0].name;
                    activeAreaName = areaSelect.value;
                } else {
                    const option = document.createElement('option');
                    option.textContent = 'Ch∆∞a c√≥ khu v·ª±c n√†o';
                    areaSelect.appendChild(option);
                    activeAreaName = null;
                }
                updateOverlays(validAreas);
            })
            .catch(error => console.error('Error fetching working areas:', error));
    }

    // H√†m c·∫≠p nh·∫≠t c√°c overlay tr√™n b·∫£n ƒë·ªì
    function updateOverlays(serverAreas) {
        // 1. X√≥a to√†n b·ªô c√°c overlay hi·ªán c√≥ tr√™n OpenSeadragon viewer
        for (const name in workingAreaOverlays) {
            viewer.removeOverlay(workingAreaOverlays[name].element);
        }
        // 2. X√≥a to√†n b·ªô d·ªØ li·ªáu l∆∞u tr·ªØ tr√™n client
        workingAreaOverlays = {};

        // 3. T·∫°o l·∫°i c√°c overlay t·ª´ d·ªØ li·ªáu m·ªõi nh·∫•t c·ªßa server
        serverAreas.forEach(area => {
            if (!area || !area.name || !area.coords) {
                console.error("Invalid area data received:", area);
                return;
            }

            const element = createAreaElement(area.name);
            const overlay = viewer.addOverlay({
                element: element,
                location: viewer.viewport.imageToViewportRectangle(new OpenSeadragon.Rect(
                    area.coords.x, area.coords.y, area.coords.width, area.coords.height
                ))
            });
            workingAreaOverlays[area.name] = { element: element, data: area.coords, overlay: overlay };
        });

        updateOverlayStyles();
    }

    // H√†m c·∫≠p nh·∫≠t ki·ªÉu d√°ng c·ªßa overlay ƒë·ªÉ l√†m n·ªïi b·∫≠t khung ƒëang ƒë∆∞·ª£c ch·ªçn
    function updateOverlayStyles() {
        for (const name in workingAreaOverlays) {
            const overlay = workingAreaOverlays[name].element;
            if (name === activeAreaName) {
                overlay.classList.add('active-area');
            } else {
                overlay.classList.remove('active-area');
            }
        }
    }
    

    // X√≥a khu v·ª±c khi nh·∫•n n√∫t
    deleteAreaBtn.addEventListener('click', function() {
        const selectedAreaName = areaSelect.value;
        if (selectedAreaName && selectedAreaName !== 'Ch∆∞a c√≥ khu v·ª±c n√†o') {
            fetch('/update_working_area', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'delete', area_name: selectedAreaName })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Area deleted:', data.message);
                    updateAreaSelectAndOverlays();
                }
            })
            .catch(error => console.error('Error deleting area:', error));
        }
    });


    // H√†m t·∫°o ph·∫ßn t·ª≠ HTML cho khu v·ª±c l√†m vi·ªác
    function createAreaElement(name) {
        const element = document.createElement('div');
        element.className = 'working-area-overlay';
        element.dataset.areaName = name;
        
        const label = document.createElement('div');
        label.className = 'area-label';
        label.textContent = name;
        element.appendChild(label);

        element.addEventListener('click', function(e) {
            e.stopPropagation();
            const name = e.currentTarget.dataset.areaName;
            activeAreaName = name;
            areaSelect.value = name;
            updateOverlayStyles();
        });

        return element;
    }

    // G·ª≠i d·ªØ li·ªáu khu v·ª±c l√†m vi·ªác l√™n server
    function sendAreaUpdate(areaName, areaCoords, action) {
        const dataToSend = {
            action: action,
            area: {
                name: areaName,
                coords: {
                    x: Math.round(areaCoords.x),
                    y: Math.round(areaCoords.y),
                    width: Math.round(areaCoords.width),
                    height: Math.round(areaCoords.height)
                }
            }
        };

        fetch('/update_working_area', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(dataToSend)
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(errorData => {
                    throw new Error(errorData.message || `Server responded with status: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Server response:', data.message);
        })
        .catch(error => console.error('Error updating area on server:', error))
        .finally(() => {
            updateAreaSelectAndOverlays();
        });
    }

    // L·∫Øng nghe s·ª± ki·ªán di chuy·ªÉn v√† ph√≥ng to/thu nh·ªè ƒë·ªÉ c·∫≠p nh·∫≠t v·ªã tr√≠ overlay
    viewer.addHandler('viewport-change', function() {
        for (const name in workingAreaOverlays) {
            const overlayData = workingAreaOverlays[name];
            if (overlayData.overlay) {
                const viewportRect = viewer.viewport.imageToViewportRectangle(new OpenSeadragon.Rect(
                    overlayData.data.x, overlayData.data.y, overlayData.data.width, overlayData.data.height
                ));
                overlayData.overlay.setLocation(viewportRect);
            }
        }
    });

    // T·∫£i c√°c khu v·ª±c ƒë√£ l∆∞u khi trang ƒë∆∞·ª£c t·∫£i
    updateAreaSelectAndOverlays();


    
</script>
{% endblock %}